#!/bin/bash
#--------------------------------------------------------------------------------
# This file is part of the IDA research data storage service
#
# Copyright (C) 2018 Ministry of Education and Culture, Finland
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License,
# or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public
# License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# @author   CSC - IT Center for Science Ltd., Espoo Finland <servicedesk@csc.fi>
# @license  GNU Affero General Public License, version 3
# @link     https://research.csc.fi/
#--------------------------------------------------------------------------------
#
# This script initializes a set of demo user accounts (project groups, users,
# group memberships, and files) which are used for demos, training, usability
# testing and general review of the IDA service.
#
# Project and user accounts will be created for 100 distinct projects, with
# randomly generated password suffixes:
#
# Demo_Project_1          demo_user_1           Demo_Password_1_d82b
# Demo_Project_2          demo_user_2           Demo_Password_2_53a9
# ...
# Demo_Project_100        demo_user_100         Demo_Password_100_3ef7
#
# NOTE: If the PAS version of the script is executed, all project and user names will be
# prefixed with 'fddps_' and project names will be in lowercase:
#
# fddps_demo_project_1    fddps_demo_user_1     Demo_Password_1_d82b
# fddps_demo_project_2    fddps_demo_user_2     Demo_Password_2_53a9
# ...
# fddps_demo_project_100  fddps_demo_user_100   Demo_Password_100_3ef7
#
# The newly generated credentials will be saved to a file with a pathname matching the
# pattern /tmp/[fddps_]demo_user_credentials.YYYY-MM-DD, the contents of which will be
# also be emailed to the configured IDA dev distribution list.
#
# All projects will be initialized without any data.
#
# Usage: initialize-demo-accounts [ <cnt> | <min> <max> ] [ --clean | --flush ]
#        initialize-demo-accounts -h
#
# If a single numeric argument between 0 and 100 is given, then only that specific demo
# account will be (re)generated or flushed.
#
# If a pair of numeric arguments between 0 and 100 is given, representing minimum
# and maximum range limits, then only the specific demo accounts within that range,
# inclusive, will be (re)generated or flushed.
#
# If the argument "--clean" is given, then any existing data for the specified accounts
# will be deleted but the accounts will remain otherwise unchanged.
#
# If the argument "--flush" is given, then only the existing accounts and data
# are fully purged and no new accounts will be created.
#
# EXAMPLES:
#
# Fully (re)initialize all regular demo accounts (remove any existing data
# from IDA and Metax, and generate accounts with new passwords):
#
#     initialize-demo-accounts
#
# Fully (re)initialize all PAS demo accounts:
#
#     initialize-pas-demo-accounts
#
# Fully (re)initialize regular demo account 11:
#
#     initialize-demo-accounts 11
#
# Fully (re)initialize PAS demo account 37:
#
#     initialize-pas-demo-accounts 37
#
# Fully (re)initialize all regular demo accounts 30 through 39:
#
#     initialize-demo-accounts 30 39
#
# Clean all regular demo accounts (remove all data from IDA and Metax, leaving
# accounts otherwise unchanged):
#
#     initialize-demo-accounts --clean
#
# Flush all regular demo accounts (remove all data from IDA and Metax, and
# delete project and user accounts from IDA):
#
#     initialize-demo-accounts --flush
#
# Clean PAS demo account 74:
#
#     initialize-pas-demo-accounts 74 --clean
#
#--------------------------------------------------------------------------------

SCRIPT_PATHNAME="$(realpath -s $0)"
SCRIPT=`basename $SCRIPT_PATHNAME`

USAGE="Usage: $SCRIPT [ <cnt> | <min> <max> ] [ --clean | --flush ]
       $SCRIPT -h"

. `dirname $0`/../../lib/init_script.sh

#DEBUG="true" # TEMP HACK

#--------------------------------------------------------------------------------
# Verify that we are not in production

if [ "$IDA_ENVIRONMENT" = "PRODUCTION" ]; then
    echo "Error: This script can not be run in a production environment. Aborting." >&2
    exit 1
fi

#--------------------------------------------------------------------------------

unset OC_PASS
export OC_PASS=""

PADDING="-50"

function failure {
    echo "FAILED: " "$@"
}

function success {
    echo "OK"
}

function skipped {
    echo "(skipped)"
}

#--------------------------------------------------------------------------------
# Variable and flag initialization...

PROJECT_BASE="Demo_Project"
USER_BASE="demo_user"
PROJECT_MIN=1
PROJECT_MAX=100
CLEAN="false"
FLUSH="false"
PAS="false"

if [ "$SCRIPT" = "initialize-pas-demo-accounts" ]; then
    PAS="true"
    PROJECT_BASE="fddps_demo_project"
    USER_BASE="fddps_demo_user"
fi

NEW_CREDENTIALS_FILE="/tmp/new_${USER_BASE}_credentials.${TIMESTAMP}"
MASTER_CREDENTIALS_FILE="/${STORAGE_OC_DATA_ROOT}/demo_account_management/${USER_BASE}_credentials"

if [ ! -e $MASTER_CREDENTIALS_FILE ]; then
    echo "Error: Master credentials file not found: $MASTER_CREDENTIALS_FILE" >&2
    exit 1
fi

#--------------------------------------------------------------------------------
# Process command line arguments...

for var in "$@"
do
    case $var in
        "-h" | "--help")
            echo "$USAGE"
            exit 0
            ;;
        "--clean")
            CLEAN="true"
            ;;
        "--flush")
            FLUSH="true"
            ;;
        *)
            if [ -z "${var##*[!0-9]*}" ]; then
                echo "Error: invalid parameter: $var" >&2
                echo "$USAGE" >&2
                exit 1
            fi
            if [ "$PROJECT_MIN" = "1" ]; then
                PROJECT_MIN=$var
                PROJECT_MAX=$var
            else
                PROJECT_MAX=$var
            fi
            ;;
    esac
done

if [ "$DEBUG" = "true" ]; then
    echo "PREFIX: $PREFIX"
    echo "MIN:    $PROJECT_MIN"
    echo "MAX:    $PROJECT_MAX"
    echo "CLEAN:  $CLEAN"
    echo "FLUSH:  $FLUSH"
    echo "MCFILE: $MASTER_CREDENTIALS_FILE"
    echo "NCFILE: $NEW_CREDENTIALS_FILE"
fi

if [ "$CLEAN" = "true" -a "$FLUSH" = "true" ]; then
    echo "Error: Only one option 'clean' or 'flush' may be specified at the same time" >&2
    echo "$USAGE" >&2
    exit 1
fi

if [ "$CLEAN" = "false" -a "$FLUSH" = "false" ]; then
    if [ $# -gt 2 ]; then
        echo "Error: Too many arguments specified" >&2
        echo "$USAGE" >&2
        exit 1
    fi
fi

if [ "$CLEAN" = "true" -o "$FLUSH" = "true" ]; then
    if [ $# -gt 3 ]; then
        echo "Error: Too many arguments specified" >&2
        echo "$USAGE" >&2
        exit 1
    fi
fi

if [ $PROJECT_MIN -lt 1 ]; then
    echo "Error: The range minimum must be greater than or equal to 1" >&1
    exit 1
fi

if [ $PROJECT_MAX -gt 100 ]; then
    echo "Error: The range maximum must be less than or equal to 100" >&1
    exit 1
fi

if [ $PROJECT_MIN -gt $PROJECT_MAX ]; then
    echo "Error: The range minimum must be less than the range maximum" >&2
    exit 1
fi

#--------------------------------------------------------------------------------
# Initialize master credentials hash table from persistent credentials file

declare -A MASTER_CREDENTIALS

while read -r USER PASSWORD; do
    MASTER_CREDENTIALS["$USER"]="$PASSWORD"
done < $MASTER_CREDENTIALS_FILE

if [ "${#MASTER_CREDENTIALS[@]}" != "100" ]; then
    echo "Error: Invalid master credentials file: $MASTER_CREDENTIALS_FILE" >&2
    exit 1
fi

#--------------------------------------------------------------------------------
# Clean all data from IDA file storage, and all action and frozen node records
# from IDA database, and all frozen node and dataset records from Metax

echo "Cleaning all project data from IDA file storage..."

COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
    PROJECT="${PROJECT_BASE}_${COUNT}"
    COUNT=$(( $COUNT + 1 ))
    # Use the PSO account when flushing the project data, NOT the admin account
    # This ensures we never accidentally flush any data other than belonging to
    # a demo project!
    PROJECT_USER="${PROJECT_USER_PREFIX}${PROJECT}"
    STEP="    Cleaning $PROJECT"
    printf "%${PADDING}s" "$STEP"
    # If there is no project user folder, skip 
    if [ ! -d "${STORAGE_OC_DATA_ROOT}/${PROJECT_USER}/" ]; then
        skipped
        continue
    fi
    PROJECT_ROOT="${STORAGE_OC_DATA_ROOT}/${PROJECT_USER}"
    PROJECT_FROZEN_FOLDER="${PROJECT_ROOT}/files/${PROJECT}"
    PROJECT_STAGING_FOLDER="${PROJECT_ROOT}/files/${PROJECT}${STAGING_FOLDER_SUFFIX}"
    rm -fr $PROJECT_FROZEN_FOLDER/*
    rm -fr $PROJECT_STAGING_FOLDER/*
    OUT=`$ROOT/nextcloud/occ files:scan $PROJECT_USER 2>&1`
    if [ "$?" -ne 0 ]; then
        OUT="$OUT (ignored)"
        failure "$OUT"
    else
        success
    fi
done

echo "Cleaning all frozen file records from IDA database..."

COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
    PROJECT="${PROJECT_BASE}_${COUNT}"
    COUNT=$(( $COUNT + 1 ))
    # Use the PSO account when flushing the project data, NOT the admin account
    # This ensures we never accidentally flush any data other than belonging to
    # a demo project!
    PROJECT_USER="${PROJECT_USER_PREFIX}${PROJECT}"
    STEP="    Cleaning $PROJECT"
    printf "%${PADDING}s" "$STEP"
    # If there is no project user folder, skip 
    if [ ! -d "${STORAGE_OC_DATA_ROOT}/${PROJECT_USER}/" ]; then
        skipped
        continue
    fi
    $CURL_POST $PROJECT_USER:$PROJECT_USER_PASS "$URL_BASE_IDA/api/flush?project=$PROJECT" 2>&1 >/dev/null
    if [ "$?" -ne 0 ]; then
        failure "Failed to clean records for $PROJECT. (ignored)."
    else
        success
    fi
done

if [ "$METAX_AVAILABLE" = "1" ]; then

    echo "Cleaning all frozen file records from Metax database..."

    COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
        PROJECT="${PROJECT_BASE}_${COUNT}"
        COUNT=$(( $COUNT + 1 ))
        STEP="    Cleaning $PROJECT"
        printf "%${PADDING}s" "$STEP"
        OUT=`$CURL_POST $METAX_API_USER:$METAX_API_PASS "$METAX_API_RPC_URL/files/flush_project?project_identifier=$PROJECT" 2>&1`
        if [ "$?" -ne 0 ]; then
            failure "$OUT (ignored)"
        else
            success
        fi
    done

    echo "Cleaning all dataset records from Metax database..."

    COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
        USER="${USER_BASE}_${COUNT}"
        COUNT=$(( $COUNT + 1 ))
        STEP="    Cleaning $USER"
        printf "%${PADDING}s" "$STEP"
        OUT=`$CURL_POST $METAX_API_USER:$METAX_API_PASS "$METAX_API_RPC_URL/datasets/flush_user_data?metadata_provider_user=$USER" 2>&1`
        if [ "$?" -ne 0 ]; then
            failure "$OUT (ignored)"
        else
            success
        fi
    done

fi

echo "Cleaning all replicated data files..."

COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
    PROJECT="${PROJECT_BASE}_${COUNT}"
    COUNT=$(( $COUNT + 1 ))
    STEP="    Cleaning $PROJECT"
    printf "%${PADDING}s" "$STEP"
    # If there is no replication project folder, skip 
    if [ ! -d "${DATA_REPLICATION_ROOT}/projects/${PROJECT}" ]; then
        skipped
        continue
    fi
    OUT=`/bin/rm -fr $DATA_REPLICATION_ROOT/projects/$PROJECT 2>&1`
    if [ "$?" -ne 0 ]; then
        failure "$OUT (ignored)"
    else
        success
    fi
done

#--------------------------------------------------------------------------------
# If only cleaning accounts, we are now done, so exit.

if [ "$CLEAN" = "true" ]; then
    echo "Done"
    exit
fi

#--------------------------------------------------------------------------------

echo "Flushing any existing demo users..."

COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
    USER="${USER_BASE}_${COUNT}"
    COUNT=$(( $COUNT + 1 ))
    STEP="    Flushing $USER account from IDA"
    printf "%${PADDING}s" "$STEP"
    OUT=`$ROOT/admin/ida_user DELETE $USER 2>&1`
    if [ "$?" -ne 0 ]; then
        OUT="$OUT (ignored)"
        failure "$OUT"
    else
        success
    fi
    STEP="    Deleting any residual user folder"
    printf "%${PADDING}s" "$STEP"
    # We use an explicit pathname here rather than using the config variable to be 
    # absolutely sure we do not delete anything we didn't mean to, due to a configuration
    # or variable name error
    USER_FOLDER="/mnt/storage_vol01/ida/$USER"
    if [ "$USER_FOLDER" != "/mnt/storage_vol01/ida/" ]; then
        if [ -d $USER_FOLDER ]; then
            OUT=`rm -fr $USER_FOLDER 2>&1`
            if [ "$?" -ne 0 ]; then
                OUT="$OUT (ignored)"
                failure "$OUT"
            else
                success
            fi
        else
            success
        fi
    else
        success
    fi
done

echo "Flushing any existing demo projects..."

COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
    PROJECT="${PROJECT_BASE}_${COUNT}"
    COUNT=$(( $COUNT + 1 ))
    STEP="    Flushing $PROJECT"
    printf "%${PADDING}s" "$STEP"
    OUT=`$ROOT/admin/ida_project DISABLE $PROJECT 2>&1`
    if [ "$?" -ne 0 ]; then
        OUT="$OUT (ignored)"
        failure "$OUT"
    else
        success
    fi
done

echo "Flushing any existing project share owners..."

COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
    PROJECT="${PROJECT_BASE}_${COUNT}"
    COUNT=$(( $COUNT + 1 ))
    USER="$PROJECT_USER_PREFIX""$PROJECT"
    STEP="    Flushing $USER"
    printf "%${PADDING}s" "$STEP"
    OUT=`$OCC user:delete $USER 2>&1`
    if [ "$?" -ne 0 ]; then
        OUT="$OUT (ignored)"
        failure "$OUT"
    else
        success
    fi
    STEP="    Deleting any residual project folder"
    printf "%${PADDING}s\n" "$STEP"
    for CANDIDATE_STORAGE_VOLUME in ${STORAGE_CANDIDATES[*]}; do
        TARGET=`echo "${CANDIDATE_STORAGE_VOLUME}/${PROJECT_USER_PREFIX}${PROJECT}" | sed -e 's/^[[:blank:]]*//;s/[[:blank:]]*$//'`
        if [ "$TARGET" != "/" ]; then
            if [ "$TARGET" != "${CANDIDATE_STORAGE_VOLUME}/" ]; then
                if [ -e "$TARGET" ]; then
                    STEP="        Deleting $TARGET "
                    printf "%${PADDING}s" "$STEP"
                    OUT=`rm -fr "$TARGET"`
                    if [ "$?" -ne 0 ]; then
                        failure "$OUT (ignored)"
                    else
                        success
                    fi
                fi
            fi
        fi
    done
done

#--------------------------------------------------------------------------------
# Generate new passwords for users and push new credentials to IdM
#
# We only record those new passwords in the master credentials if we are
# re-initializing the accounts, otherwise they are discarded after pushing them
# to the test IdM and the master credentials are updated with the invalid password
# '(disabled)' which cannot be used for authentication -- thus if only flushing,
# those new passwords are discarded and not recorded, and thus those accounts are
# effectively disabled in the test IdM.

declare -A NEW_CREDENTIALS

cp /dev/null $NEW_CREDENTIALS_FILE

COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
    PROJECT="${PROJECT_BASE}_${COUNT}"
    USER="${USER_BASE}_${COUNT}"
    TOKEN=`tr -cd '[:alnum:]' < /dev/urandom | head -c64 | sed -e 's/[^a-zA-Z0-9]//' | sed -e 's/[015oOiIlLsS]//g' | head -c4 | tr 'A-Z' 'a-z'`
    PASSWORD="Demo_Password_${COUNT}_${TOKEN}"
    NEW_CREDENTIALS["$USER"]="$PASSWORD"
    OUTPUT=$(printf "   %-20s%s" "$USER" "$PASSWORD")
    echo "$OUTPUT" >> $NEW_CREDENTIALS_FILE
    COUNT=$(( $COUNT + 1 ))
done

#--------------------------------------------------------------------------------
# If not merely flushing accounts, initialize new accounts...

if [ "$FLUSH" != "true" ]; then

    echo "Creating new demo accounts..."
    echo "Creating projects..."
    
    COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
        PROJECT="${PROJECT_BASE}_${COUNT}"
        COUNT=$(( $COUNT + 1 ))
        STEP="    Creating $PROJECT"
        printf "%${PADDING}s" "$STEP"
        OUT=`$ROOT/admin/ida_project ADD $PROJECT 1 2>&1`
        if [ "$?" -ne 0 ]; then
            failure "$OUT"
        else
            success
        fi
    done
    
    #--------------------------------------------------------------------------------
    
    echo "Creating users..."
    
    COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
        PROJECT="${PROJECT_BASE}_${COUNT}"
        USER="${USER_BASE}_${COUNT}"
        export OC_PASS="${NEW_CREDENTIALS[$USER]}"
        STEP="    Creating $USER"
        printf "%${PADDING}s" "$STEP"
        OUT=`$ROOT/admin/ida_user ADD $USER $PROJECT 2>&1`
        if [ "$?" -ne 0 ]; then
            failure "$OUT"
        else
            echo ""
        fi
        COUNT=$(( $COUNT + 1 ))
    done
    
fi

#--------------------------------------------------------------------------------
# Push new credentials to test IdM

if [ "$FLUSH" = "true" ]; then
    if [ "$PAS" = "true" ]; then
        echo "Disabling flushed PAS demo accounts in test IdM..."
    else
        echo "Disabling flushed demo accounts in test IdM..."
    fi
else
    if [ "$PAS" = "true" ]; then
        echo "Pushing updated PAS demo account credentials to test IdM..."
    else
        echo "Pushing updated demo account credentials to test IdM..."
    fi
fi

OUT=`$ROOT/utils/admin/push-credentials-to-test-idm $NEW_CREDENTIALS_FILE 2>&1`
PID=`echo "$OUT" | sed -e 's/^\w*workflow:\w*//'`

if [ -z "$PID" ]; then
    echo "Error: failed to update accounts in test IdM" >&2
    echo "$OUT" >&2
    exit 1
fi

LOOP=1

while true; do
    OUT=`$ROOT/utils/admin/check-test-idm-workflow $PID 2>&1`
    echo "    $OUT"
    RUNNING=`echo "$OUT" | grep 'status: running'`
    if [ -z "$RUNNING" ]; then
        break
    fi
    LOOP=$(( LOOP + 1 ))
    if [ $LOOP -gt 100 ]; then
        echo "Error: timeout exceeded while waiting for IdM workflow to complete" >&2
        exit 1
    fi
done

#--------------------------------------------------------------------------------
# Update master credentials persistent file

echo "Updating persistent credentials..."

COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
    USER="${USER_BASE}_${COUNT}"
    if [ "$FLUSH" = "true" ]; then
        PASSWORD="(disabled)"
    else
        PASSWORD="${NEW_CREDENTIALS[$USER]}"
    fi
    MASTER_CREDENTIALS["$USER"]="$PASSWORD"
    COUNT=$(( $COUNT + 1 ))
done

cp /dev/null $MASTER_CREDENTIALS_FILE

COUNT=1; while [ $COUNT -le 100 ]; do
    USER="${USER_BASE}_${COUNT}"
    PASSWORD="${MASTER_CREDENTIALS[$USER]}"
    OUTPUT=$(printf "   %-20s%s" "$USER" "$PASSWORD")
    echo "$OUTPUT" >> $MASTER_CREDENTIALS_FILE
    COUNT=$(( $COUNT + 1 ))
done

#--------------------------------------------------------------------------------

echo "Updated credentials:"
COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
    USER="${USER_BASE}_${COUNT}"
    PASSWORD="${MASTER_CREDENTIALS[$USER]}"
    OUTPUT=$(printf "   %-20s%s" "$USER" "$PASSWORD")
    echo "$OUTPUT"
    COUNT=$(( $COUNT + 1 ))
done

#--------------------------------------------------------------------------------

echo "Done"
addToLog "DONE"
