#!/srv/venv-agents/bin/python
#--------------------------------------------------------------------------------
# This file is part of the IDA research data storage service
#
# Copyright (C) 2018 Ministry of Education and Culture, Finland
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License,
# or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public
# License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# @author   CSC - IT Center for Science Ltd., Espoo Finland <servicedesk@csc.fi>
# @license  GNU Affero General Public License, version 3
# @link     https://research.csc.fi/
#
#--------------------------------------------------------------------------------
#
# TODO: Update the behavior of this script and/or METAX so that:
#
# 1. The parameters provided to the script will be a project name, a JSON file
#    with file details from IDA, a config file, and a boolean flag '0' or '1'
#    indicating whether METAX should consider the file details input as
#    exhaustive or partial.
#
#    No legacy custom metadata will be provided.
#
# 2. METAX will update file details per the provided input for known files
#    rather than either replacing the existing file record or ignoring the input
#    for those files.
#
#    The status of the METAX file record associated with a file PID should
#    correspond to the status indicated in the input, whether frozen or
#    deleted/removed.
#
# 3. METAX will create new records for frozen files not known at all, the
#    same as usual.
#
# 4. If the boolean flag provided is '1', indicating the file details input
#    should be considered exhaustive, METAX will mark as deleted/removed all
#    files associated with the project which are not included in the provided
#    file details.
#
# An error should be reported if any files in the input are associated with a
# project other than the project specified (the script / repair operation should
# be restricted to the scope of a single project).
#
# Thus, when repairing file metadata in METAX, IDA must be considered the
# authority for frozen file metadata such that METAX records will be updated
# to reflect whatever values are specified in the input file details; while
# at the same time preserving all other existing metadata, especially legacy
# custom metadata, associated with each known file PID.
#
#--------------------------------------------------------------------------------

from datetime import datetime
from json import load
from sys import argv, exit, stderr
from time import time
import importlib.util
import os
import traceback
import urllib3

import requests

"""
A script to:
- form METAX-compatible file metadata based on a list of files,
- complement the standard file metadata with custom metadata, if any,
- and upload the resulting file metadata to METAX.

Requires three parameters, all of which are file paths:
- path to a json file containing a list of files, in similar format as received from IDA api
- path to a json file containing custom file metadata. file may be empty
- path to a config.sh file, which contains METAX API root url, username and password

The last parameter can be replaced with "--no-config", in which case a custom config-object
is returned instead. Customize the config object as necessary in the method get_config.
"""

urllib3.disable_warnings()
current_time = datetime.utcnow().replace(microsecond=0).isoformat() + 'Z'

def print_err(msg):
    stderr.write('%s\n' % msg)


def get_config(config_file_path):
    """
    mostly copy-paste from somewhere to get vars from config.sh...
    """
    if config_file_path == "--no-config":
        # for testing
        return {
            'METAX_API_ROOT_URL': 'https://metax.csc.local/rest',
            'METAX_API_USER': 'metax',
            'METAX_API_PASS': 'test-metax',
        }

    made_up_module_name = "server_configuration.variables"
    try:
        # python versions >= 3.5
        module_spec = importlib.util.spec_from_file_location(made_up_module_name, config_file_path)
        module = importlib.util.module_from_spec(module_spec)
        module_spec.loader.exec_module(module)
    except AttributeError:
        # python versions < 3.5
        from importlib.machinery import SourceFileLoader
        module = SourceFileLoader(made_up_module_name, config_file_path).load_module()

    return {
        'METAX_API_ROOT_URL': module.METAX_API_ROOT_URL,
        'METAX_API_USER': module.METAX_API_USER,
        'METAX_API_PASS': module.METAX_API_PASS,
    }


def get_custom_metadata_for_file(file):
    for i, metadata_entry in enumerate(files_metadata):
        if metadata_entry['pid'] == file['pid']:
            del files_metadata[i]
            return metadata_entry['metadata']
    return None


def form_file_metadata(node):
    md = {
        'byte_size': node['size'],
        'checksum': {
            'value': node['checksum'].split('sha256:')[-1],
            'algorithm': 'sha2',
            'checked': current_time,
        },
        'file_frozen': node['frozen'],
        'file_modified': node['modified'],
        'file_name': os.path.split(node['pathname'])[1],
        'file_path': node['pathname'],
        'file_storage': 1,
        'file_uploaded': current_time,
        'identifier': node['pid'],
        'open_access': True,
        'project_identifier': node['project'],
    }

    file_format = os.path.splitext(node['pathname'])[1][1:]
    if file_format:
        md['file_format'] = file_format

    custom_metadata = get_custom_metadata_for_file(node)
    if custom_metadata:
        md['file_characteristics_extension'] = { 'ida_legacy_metadata': custom_metadata }

    return md


if __name__ == '__main__':
    if len(argv) < 2:
        print_err('Did not receive any arguments. Aborting')
        exit(1)

    try:
        file_path_action_files = argv[1]
        file_path_files_metadata = argv[2]
        config_file_path = argv[3]
    except Exception:
        print_err('Expected three arguments')
        exit(1)

    try:
        with open(file_path_action_files, 'r') as f:
            action_files = load(f)
        with open(file_path_files_metadata, 'r') as f:
            files_metadata = load(f)
    except Exception:
        print_err('Could not open file...')
        print_err(traceback.format_exc())
        exit(1)

    try:
        config = get_config(config_file_path)
    except Exception:
        print_err('Could not open config.sh...')
        print_err(traceback.format_exc())
        exit(1)

    action_pid = file_path_action_files.split('-')[-1][:-5]
    custom_metadata_included = 0

    print('Processing action %s' % action_pid)
    print('\tForming file metadata...')

    all_file_metadata = []
    for file in action_files:
        md = form_file_metadata(file)
        if 'file_characteristics_extension' in md:
            custom_metadata_included += 1
        all_file_metadata.append(md)

    print('\tUploading file metadata (%d files)...' % len(all_file_metadata))

    # Note - using parameter ?ignore_already_exists_errors=true results in a particular
    # file being ignored / skipped if it already has metadata stored in METAX. This
    # facilitates easier testing without having to continually flush project data.
    start = time()
    response = requests.post(
        '%s/files?ignore_already_exists_errors=true' % config['METAX_API_ROOT_URL'],
        json=all_file_metadata,
        auth=(config['METAX_API_USER'], config['METAX_API_PASS']),
        verify=False
    )
    end = time()

    if response.status_code != 201:
        print_err('METAX returned an error. Error of first file:')
        try:
            print_err(response.json()['failed'][0]['errors'])
            print_err('File that caused the error: %s' % response.json()['failed'][0]['object']['identifier'])
        except Exception:
            print_err(response.content)
        exit(1)

    print('\tCreated %d new files.' % len(all_file_metadata))
    print('\tCustom metadata included in %d files.' % custom_metadata_included)
    print('\tMetadata upload took %.2f seconds.' % (end - start))

    # NOTE: The bootstrapping process employed by the IDA app, when files are imported and the migration actions
    # are created sets all timestamps to the same value, therefore it is not necessary to update the action timestamp
    # as part of this step.

    exit(0)
