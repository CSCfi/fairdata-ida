#!/bin/bash
#--------------------------------------------------------------------------------
# This file is part of the IDA research data storage service
#
# Copyright (C) 2018 Ministry of Education and Culture, Finland
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License,
# or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public
# License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# @author   CSC - IT Center for Science Ltd., Espoo Finland <servicedesk@csc.fi>
# @license  GNU Affero General Public License, version 3
# @link     https://research.csc.fi/
#--------------------------------------------------------------------------------
#
# This script initializes a set of demo user accounts (project groups, users,
# group memberships, and files) which are used for demos, training, usability
# testing and general review of the IDA service.
#
# Project and user accounts will be created for 100 distinct projects, with
# randomly generated password suffixes:
#
# Demo_Project_1          demo_user_1           Demo_Password_1_d82b
# Demo_Project_2          demo_user_2           Demo_Password_2_53a9
# ...
# Demo_Project_100        demo_user_100         Demo_Password_100_3ef7
#
# NOTE: If the PAS version of the script is executed, all project and user names will be
# prefixed with 'fddps_' and project names will be in lowercase:
#
# fddps_demo_project_1    fddps_demo_user_1     Demo_Password_1_d82b
# fddps_demo_project_2    fddps_demo_user_2     Demo_Password_2_53a9
# ...
# fddps_demo_project_100  fddps_demo_user_100   Demo_Password_100_3ef7
#
# The newly generated credentials will be saved to a file with a pathname matching the
# pattern /tmp/[fddps_]demo_user_credentials.YYYY-MM-DD, the contents of which will be
# also be emailed to the configured IDA dev distribution list.
#
# All projects will be initialized without any data.
#
# Usage: initialize-demo-accounts [ <cnt> | <min> <max> ] [ --clean | --flush ]
#        initialize-demo-accounts -h
#
# If a single numeric argument between 0 and 100 is given, then only that specific demo
# account will be (re)generated or flushed.
#
# If a pair of numeric arguments between 0 and 100 is given, representing minimum
# and maximum range limits, then only the specific demo accounts within that range,
# inclusive, will be (re)generated or flushed.
#
# If the argument "--clean" is given, then any existing data for the specified accounts
# will be deleted but the accounts will remain otherwise unchanged.
#
# If the argument "--flush" is given, then only the existing accounts and data
# are fully purged and no new accounts will be created.
#
# EXAMPLES:
#
# Fully (re)initialize all regular demo accounts (remove any existing data
# from IDA and Metax, and generate accounts with new passwords):
#
#     initialize-demo-accounts
#
# Fully (re)initialize all PAS demo accounts:
#
#     initialize-pas-demo-accounts
#
# Fully (re)initialize regular demo account 11:
#
#     initialize-demo-accounts 11
#
# Fully (re)initialize PAS demo account 37:
#
#     initialize-pas-demo-accounts 37
#
# Fully (re)initialize all regular demo accounts 30 through 39:
#
#     initialize-demo-accounts 30 39
#
# Clean all regular demo accounts (remove all data from IDA and Metax, leaving
# accounts otherwise unchanged):
#
#     initialize-demo-accounts --clean
#
# Flush all regular demo accounts (remove all data from IDA and Metax, and
# delete project and user accounts from IDA):
#
#     initialize-demo-accounts --flush
#
# Clean PAS demo account 74:
#
#     initialize-pas-demo-accounts 74 --clean
#
#--------------------------------------------------------------------------------

SCRIPT_PATHNAME="$(realpath -s $0)"
SCRIPT=`basename $SCRIPT_PATHNAME`

USAGE="Usage: $SCRIPT [ <cnt> | <min> <max> ] [ --clean | --flush ]
       $SCRIPT -h"

. `dirname $0`/../lib/init_script.sh

#DEBUG="true" # TEMP HACK

#--------------------------------------------------------------------------------
# Verify that we are not in production

if [ "$IDA_ENVIRONMENT" = "PRODUCTION" ]; then
    echo "Error: This script can not be run in a production environment. Aborting." >&2
    exit 1
fi

#--------------------------------------------------------------------------------

unset OC_PASS
export OC_PASS=""

PADDING="-50"

function failure {
    echo "FAILED: " "$@"
}

function success {
    echo "OK"
}

function skipped {
    echo "(skipped)"
}

#--------------------------------------------------------------------------------
# Variable and flag initialization...

PROJECT_BASE="Demo_Project"
USER_BASE="demo_user"
PROJECT_MIN=1
PROJECT_MAX=100
CLEAN="false"
FLUSH="false"
HEADER="Demo Account Credentials"

if [ "$SCRIPT" = "initialize-pas-demo-accounts" ]; then
    PROJECT_BASE="fddps_demo_project"
    USER_BASE="fddps_demo_user"
    HEADER="PAS ${HEADER}"
fi

PWFILE="/tmp/${USER_BASE}_credentials.${TIMESTAMP}"
SERVER=`hostname`
HEADER="${HEADER} ${SERVER}:${PWFILE}"

#--------------------------------------------------------------------------------
# Process command line arguments...

for var in "$@"
do
    case $var in
        "-h" | "--help")
            echo "$USAGE"
            exit 0
            ;;
        "--clean")
            CLEAN="true"
            ;;
        "--flush")
            FLUSH="true"
            ;;
        *)
            if [ -z "${var##*[!0-9]*}" ]; then
                echo "Error: invalid parameter: $var" >&2
                echo "$USAGE" >&2
                exit 1
            fi
            if [ "$PROJECT_MIN" = "1" ]; then
                PROJECT_MIN=$var
                PROJECT_MAX=$var
            else
                PROJECT_MAX=$var
            fi
            ;;
    esac
done

if [ "$DEBUG" = "true" ]; then
    echo "PREFIX: $PREFIX"
    echo "MIN:    $PROJECT_MIN"
    echo "MAX:    $PROJECT_MAX"
    echo "CLEAN:  $CLEAN"
    echo "FLUSH:  $FLUSH"
    echo "PWFILE: $PWFILE"
    echo "HEADER: $HEADER"
fi

if [ "$CLEAN" = "true" -a "$FLUSH" = "true" ]; then
    echo "Error: Only one option 'clean' or 'flush' may be specified at the same time" >&2
    echo "$USAGE" >&2
    exit 1
fi

if [ "$CLEAN" = "false" -a "$FLUSH" = "false" ]; then
    if [ $# -gt 2 ]; then
        echo "Error: Too many arguments specified" >&2
        echo "$USAGE" >&2
        exit 1
    fi
fi

if [ "$CLEAN" = "true" -o "$FLUSH" = "true" ]; then
    if [ $# -gt 3 ]; then
        echo "Error: Too many arguments specified" >&2
        echo "$USAGE" >&2
        exit 1
    fi
fi

if [ $PROJECT_MIN -lt 1 ]; then
    echo "Error: The range minimum must be greater than or equal to 1" >&1
    exit 1
fi

if [ $PROJECT_MAX -gt 100 ]; then
    echo "Error: The range maximum must be less than or equal to 100" >&1
    exit 1
fi

if [ $PROJECT_MIN -gt $PROJECT_MAX ]; then
    echo "Error: The range minimum must be less than the range maximum" >&2
    exit 1
fi

#--------------------------------------------------------------------------------

# Clean all data from IDA file storage, and all action and frozen node records
# from IDA database, and all frozen node and dataset records from Metax

echo "Cleaning all project data from IDA file storage..."

COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
    PROJECT="${PROJECT_BASE}_${COUNT}"
    COUNT=$(( $COUNT + 1 ))
    # Use the PSO account when flushing the project data, NOT the admin account
    # This ensures we never accidentally flush any data other than belonging to
    # a demo project!
    PROJECT_USER="${PROJECT_USER_PREFIX}${PROJECT}"
    STEP="    Cleaning $PROJECT"
    printf "%${PADDING}s" "$STEP"
    # If there is no project user folder, skip 
    if [ ! -d "${STORAGE_OC_DATA_ROOT}/${PROJECT_USER}/" ]; then
        skipped
        continue
    fi
    PROJECT_ROOT="${STORAGE_OC_DATA_ROOT}/${PROJECT_USER}"
    PROJECT_FROZEN_FOLDER="${PROJECT_ROOT}/files/${PROJECT}"
    PROJECT_STAGING_FOLDER="${PROJECT_ROOT}/files/${PROJECT}${STAGING_FOLDER_SUFFIX}"
    rm -fr $PROJECT_FROZEN_FOLDER/*
    rm -fr $PROJECT_STAGING_FOLDER/*
    OUT=`$ROOT/nextcloud/occ files:scan $PROJECT_USER 2>&1`
    if [ "$?" -ne 0 ]; then
        OUT="$OUT (ignored)"
        failure "$OUT"
    else
        success
    fi
done

echo "Cleaning all frozen file records from IDA database..."

COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
    PROJECT="${PROJECT_BASE}_${COUNT}"
    COUNT=$(( $COUNT + 1 ))
    # Use the PSO account when flushing the project data, NOT the admin account
    # This ensures we never accidentally flush any data other than belonging to
    # a demo project!
    PROJECT_USER="${PROJECT_USER_PREFIX}${PROJECT}"
    STEP="    Cleaning $PROJECT"
    printf "%${PADDING}s" "$STEP"
    # If there is no project user folder, skip 
    if [ ! -d "${STORAGE_OC_DATA_ROOT}/${PROJECT_USER}/" ]; then
        skipped
        continue
    fi
    $CURL_POST $PROJECT_USER:$PROJECT_USER_PASS "$URL_BASE_IDA/api/flush?project=$PROJECT" 2>&1 >/dev/null
    if [ "$?" -ne 0 ]; then
        failure "Failed to clean records for $PROJECT. (ignored)."
    else
        success
    fi
done

if [ "$METAX_AVAILABLE" = "1" ]; then

    echo "Cleaning all frozen file records from Metax database..."

    COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
        PROJECT="${PROJECT_BASE}_${COUNT}"
        COUNT=$(( $COUNT + 1 ))
        STEP="    Cleaning $PROJECT"
        printf "%${PADDING}s" "$STEP"
        OUT=`$CURL_POST $METAX_API_USER:$METAX_API_PASS "$METAX_API_RPC_URL/files/flush_project?project_identifier=$PROJECT" 2>&1`
        if [ "$?" -ne 0 ]; then
            failure "$OUT (ignored)"
        else
            success
        fi
    done

    echo "Cleaning all dataset records from Metax database..."

    COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
        USER="${USER_BASE}_${COUNT}"
        COUNT=$(( $COUNT + 1 ))
        STEP="    Cleaning $USER"
        printf "%${PADDING}s" "$STEP"
        OUT=`$CURL_POST $METAX_API_USER:$METAX_API_PASS "$METAX_API_RPC_URL/datasets/flush_user_data?metadata_provider_user=$USER" 2>&1`
        if [ "$?" -ne 0 ]; then
            failure "$OUT (ignored)"
        else
            success
        fi
    done

fi

echo "Cleaning all replicated data files..."

COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
    PROJECT="${PROJECT_BASE}_${COUNT}"
    COUNT=$(( $COUNT + 1 ))
    STEP="    Cleaning $PROJECT"
    printf "%${PADDING}s" "$STEP"
    # If there is no replication project folder, skip 
    if [ ! -d "${DATA_REPLICATION_ROOT}/projects/${PROJECT}" ]; then
        skipped
        continue
    fi
    OUT=`/bin/rm -fr $DATA_REPLICATION_ROOT/projects/$PROJECT 2>&1`
    if [ "$?" -ne 0 ]; then
        failure "$OUT (ignored)"
    else
        success
    fi
done

#--------------------------------------------------------------------------------

if [ "$CLEAN" = "true" ]; then
    exit
fi

#--------------------------------------------------------------------------------

echo "Flushing any existing demo users..."

COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
    USER="${USER_BASE}_${COUNT}"
    COUNT=$(( $COUNT + 1 ))
    STEP="    Flushing $USER account from IDA"
    printf "%${PADDING}s" "$STEP"
    OUT=`$ROOT/admin/ida_user DELETE $USER 2>&1`
    if [ "$?" -ne 0 ]; then
        OUT="$OUT (ignored)"
        failure "$OUT"
    else
        success
    fi
    STEP="    Deleting any residual user folder"
    printf "%${PADDING}s" "$STEP"
    # We use an explicit pathname here rather than using the config variable to be 
    # absolutely sure we do not delete anything we didn't mean to, due to a configuration
    # or variable name error
    USER_FOLDER="/mnt/storage_vol01/ida/$USER"
    if [ "$USER_FOLDER" != "/mnt/storage_vol01/ida/" ]; then
        if [ -d $USER_FOLDER ]; then
            OUT=`rm -fr $USER_FOLDER 2>&1`
            if [ "$?" -ne 0 ]; then
                OUT="$OUT (ignored)"
                failure "$OUT"
            else
                success
            fi
        else
            success
        fi
    else
        success
    fi
done

echo "Flushing any existing demo projects..."

COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
    PROJECT="${PROJECT_BASE}_${COUNT}"
    COUNT=$(( $COUNT + 1 ))
    STEP="    Flushing $PROJECT"
    printf "%${PADDING}s" "$STEP"
    OUT=`$ROOT/admin/ida_project DISABLE $PROJECT 2>&1`
    if [ "$?" -ne 0 ]; then
        OUT="$OUT (ignored)"
        failure "$OUT"
    else
        success
    fi
done

echo "Flushing any existing project share owners..."

COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
    PROJECT="${PROJECT_BASE}_${COUNT}"
    COUNT=$(( $COUNT + 1 ))
    USER="$PROJECT_USER_PREFIX""$PROJECT"
    STEP="    Flushing $USER"
    printf "%${PADDING}s" "$STEP"
    OUT=`$OCC user:delete $USER 2>&1`
    if [ "$?" -ne 0 ]; then
        OUT="$OUT (ignored)"
        failure "$OUT"
    else
        success
    fi
    STEP="    Deleting any residual project folder"
    printf "%${PADDING}s\n" "$STEP"
    for CANDIDATE_STORAGE_VOLUME in ${STORAGE_CANDIDATES[*]}; do
        TARGET=`echo "${CANDIDATE_STORAGE_VOLUME}/${PROJECT_USER_PREFIX}${PROJECT}" | sed -e 's/^[[:blank:]]*//;s/[[:blank:]]*$//'`
        if [ "$TARGET" != "/" ]; then
            if [ "$TARGET" != "${CANDIDATE_STORAGE_VOLUME}/" ]; then
                if [ -e "$TARGET" ]; then
                    STEP="   Deleting $TARGET "
                    printf "%${PADDING}s" "$STEP"
                    OUT=`rm -fr "$TARGET"`
                    if [ "$?" -ne 0 ]; then
                        failure "$OUT (ignored)"
                    else
                        success
                    fi
                fi
            fi
        fi
    done
done

#--------------------------------------------------------------------------------

if [ "$FLUSH" = "true" ]; then
    exit
fi

#--------------------------------------------------------------------------------

echo "Creating new demo accounts..."
echo "Creating projects..."

COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
    PROJECT="${PROJECT_BASE}_${COUNT}"
    COUNT=$(( $COUNT + 1 ))
    STEP="    Creating $PROJECT"
    printf "%${PADDING}s" "$STEP"
    OUT=`$ROOT/admin/ida_project ADD $PROJECT 1 2>&1`
    if [ "$?" -ne 0 ]; then
        failure "$OUT"
    else
        success
    fi
done

#--------------------------------------------------------------------------------

cp /dev/null $PWFILE

echo "Creating users..."

COUNT=$PROJECT_MIN; while [ $COUNT -le $PROJECT_MAX ]; do
    PROJECT="${PROJECT_BASE}_${COUNT}"
    USER="${USER_BASE}_${COUNT}"
    TOKEN=`tr -cd '[:alnum:]' < /dev/urandom | head -c64 | sed -e 's/[^a-zA-Z0-9]//' | sed -e 's/[015oOiIlLsS]//g' | head -c4 | tr 'A-Z' 'a-z'`
    export OC_PASS="Demo_Password_${COUNT}_${TOKEN}"
    COUNT=$(( $COUNT + 1 ))
    CREDENTIALS=$(printf "   %-20s%s" "$USER" "$OC_PASS")
    echo "$CREDENTIALS" >> $PWFILE
    STEP="    Creating $USER"
    printf "%${PADDING}s" "$STEP"
    OUT=`$ROOT/admin/ida_user ADD $USER $PROJECT 2>&1`
    if [ "$?" -ne 0 ]; then
        failure "$OUT"
    else
        echo ""
    fi
done

#--------------------------------------------------------------------------------

if [ "${EMAIL_SENDER}${EMAIL_RECIPIENTS}" != "" ]; then
    cat $PWFILE | mail -r $EMAIL_SENDER -s "$HEADER" $EMAIL_RECIPIENTS
fi

echo "New demo account credentials saved to file $PWFILE"

#--------------------------------------------------------------------------------

addToLog "DONE"
