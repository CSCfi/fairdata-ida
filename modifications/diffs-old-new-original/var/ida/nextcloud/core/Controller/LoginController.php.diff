--- /var/ida/nextcloud-new/core/Controller/LoginController.php	2021-10-27 15:54:09.657759728 +0000
+++ /var/ida/nextcloud-old/core/Controller/LoginController.php.original	2021-10-27 10:25:30.755495955 +0000
@@ -4,15 +4,16 @@
  * @copyright Copyright (c) 2016 Joas Schilling <coding@schilljs.com>
  * @copyright Copyright (c) 2016, ownCloud, Inc.
  *
- * @author Christoph Wurst <christoph@winzerhof-wurst.at>
- * @author Daniel Kesselberg <mail@danielkesselberg.de>
+ * @author Arthur Schiwon <blizzz@arthur-schiwon.de>
+ * @author Christoph Wurst <christoph@owncloud.com>
  * @author Joas Schilling <coding@schilljs.com>
- * @author John Molakvoæ (skjnldsv) <skjnldsv@protonmail.com>
  * @author Julius Härtl <jus@bitgrid.net>
+ * @author justin-sleep <justin@quarterfull.com>
  * @author Lukas Reschke <lukas@statuscode.ch>
- * @author Michael Weimann <mail@michael-weimann.eu>
- * @author Rayn0r <andrew@ilpss8.myfirewall.org>
- * @author Roeland Jago Douma <roeland@famdouma.nl>
+ * @author Morris Jobke <hey@morrisjobke.de>
+ * @author Sandro Lutz <sandro.lutz@temparus.ch>
+ * @author Thomas Müller <thomas.mueller@tmit.eu>
+ * @author Ujjwal Bhardwaj <ujjwalb1996@gmail.com>
  *
  * @license AGPL-3.0
  *
@@ -32,10 +33,8 @@
 
 namespace OC\Core\Controller;
 
-use OC\AppFramework\Http\Request;
-use OC\Authentication\Login\Chain;
-use OC\Authentication\Login\LoginData;
-use OC\Authentication\WebAuthn\Manager as WebAuthnManager;
+use OC\Authentication\Token\IToken;
+use OC\Authentication\TwoFactorAuth\Manager;
 use OC\Security\Bruteforce\Throttler;
 use OC\User\Session;
 use OC_App;
@@ -45,9 +44,9 @@
 use OCP\AppFramework\Http\DataResponse;
 use OCP\AppFramework\Http\RedirectResponse;
 use OCP\AppFramework\Http\TemplateResponse;
+use OCP\Authentication\TwoFactorAuth\IProvider;
 use OCP\Defaults;
 use OCP\IConfig;
-use OCP\IInitialStateService;
 use OCP\ILogger;
 use OCP\IRequest;
 use OCP\ISession;
@@ -55,11 +54,13 @@
 use OCP\IUser;
 use OCP\IUserManager;
 use OCP\IUserSession;
+use OC\Hooks\PublicEmitter;
 use OCP\Util;
 
 class LoginController extends Controller {
-	public const LOGIN_MSG_INVALIDPASSWORD = 'invalidpassword';
-	public const LOGIN_MSG_USERDISABLED = 'userdisabled';
+
+	const LOGIN_MSG_INVALIDPASSWORD = 'invalidpassword';
+	const LOGIN_MSG_USERDISABLED = 'userdisabled';
 
 	/** @var IUserManager */
 	private $userManager;
@@ -73,18 +74,27 @@
 	private $urlGenerator;
 	/** @var ILogger */
 	private $logger;
+	/** @var Manager */
+	private $twoFactorManager;
 	/** @var Defaults */
 	private $defaults;
 	/** @var Throttler */
 	private $throttler;
-	/** @var Chain */
-	private $loginChain;
-	/** @var IInitialStateService */
-	private $initialStateService;
-	/** @var WebAuthnManager */
-	private $webAuthnManager;
 
-	public function __construct(?string $appName,
+	/**
+	 * @param string $appName
+	 * @param IRequest $request
+	 * @param IUserManager $userManager
+	 * @param IConfig $config
+	 * @param ISession $session
+	 * @param IUserSession $userSession
+	 * @param IURLGenerator $urlGenerator
+	 * @param ILogger $logger
+	 * @param Manager $twoFactorManager
+	 * @param Defaults $defaults
+	 * @param Throttler $throttler
+	 */
+	public function __construct($appName,
 								IRequest $request,
 								IUserManager $userManager,
 								IConfig $config,
@@ -92,11 +102,9 @@
 								IUserSession $userSession,
 								IURLGenerator $urlGenerator,
 								ILogger $logger,
+								Manager $twoFactorManager,
 								Defaults $defaults,
-								Throttler $throttler,
-								Chain $loginChain,
-								IInitialStateService $initialStateService,
-								WebAuthnManager $webAuthnManager) {
+								Throttler $throttler) {
 		parent::__construct($appName, $request);
 		$this->userManager = $userManager;
 		$this->config = $config;
@@ -104,11 +112,9 @@
 		$this->userSession = $userSession;
 		$this->urlGenerator = $urlGenerator;
 		$this->logger = $logger;
+		$this->twoFactorManager = $twoFactorManager;
 		$this->defaults = $defaults;
 		$this->throttler = $throttler;
-		$this->loginChain = $loginChain;
-		$this->initialStateService = $initialStateService;
-		$this->webAuthnManager = $webAuthnManager;
 	}
 
 	/**
@@ -131,11 +137,7 @@
 
 		$this->session->set('clearingExecutionContexts', '1');
 		$this->session->close();
-
-		if (!$this->request->isUserAgent([Request::USER_AGENT_CHROME, Request::USER_AGENT_ANDROID_MOBILE_CHROME])) {
-			$response->addHeader('Clear-Site-Data', '"cache", "storage"');
-		}
-
+		$response->addHeader('Clear-Site-Data', '"cache", "storage", "executionContexts"');
 		return $response;
 	}
 
@@ -154,42 +156,50 @@
 			return new RedirectResponse(OC_Util::getDefaultPageUrl());
 		}
 
+		$parameters = array();
 		$loginMessages = $this->session->get('loginMessages');
+		$errors = [];
+		$messages = [];
 		if (is_array($loginMessages)) {
 			list($errors, $messages) = $loginMessages;
-			$this->initialStateService->provideInitialState('core', 'loginMessages', $messages);
-			$this->initialStateService->provideInitialState('core', 'loginErrors', $errors);
 		}
 		$this->session->remove('loginMessages');
+		foreach ($errors as $value) {
+			$parameters[$value] = true;
+		}
 
+		$parameters['messages'] = $messages;
 		if ($user !== null && $user !== '') {
-			$this->initialStateService->provideInitialState('core', 'loginUsername', $user);
+			$parameters['loginName'] = $user;
+			$parameters['user_autofocus'] = false;
 		} else {
-			$this->initialStateService->provideInitialState('core', 'loginUsername', '');
+			$parameters['loginName'] = '';
+			$parameters['user_autofocus'] = true;
 		}
 
-		$this->initialStateService->provideInitialState(
-			'core',
-			'loginAutocomplete',
-			$this->config->getSystemValue('login_form_autocomplete', true) === true
-		);
+		$autocomplete = $this->config->getSystemValue('login_form_autocomplete', true);
+		if ($autocomplete){
+			$parameters['login_form_autocomplete'] = 'on';
+		} else {
+			$parameters['login_form_autocomplete'] = 'off';
+		}
 
 		if (!empty($redirect_url)) {
-			[$url, ] = explode('?', $redirect_url);
-			if ($url !== $this->urlGenerator->linkToRoute('core.login.logout')) {
-				$this->initialStateService->provideInitialState('core', 'loginRedirectUrl', $redirect_url);
-			}
+			$parameters['redirect_url'] = $redirect_url;
 		}
 
-		$this->initialStateService->provideInitialState(
-			'core',
-			'loginThrottleDelay',
-			$this->throttler->getDelay($this->request->getRemoteAddress())
-		);
+		$parameters = $this->setPasswordResetParameters($user, $parameters);
+		$parameters['alt_login'] = OC_App::getAlternativeLogIns();
 
-		$this->setPasswordResetInitialState($user);
+		if ($user !== null && $user !== '') {
+			$parameters['loginName'] = $user;
+			$parameters['user_autofocus'] = false;
+		} else {
+			$parameters['loginName'] = '';
+			$parameters['user_autofocus'] = true;
+		}
 
-		$this->initialStateService->provideInitialState('core', 'webauthn-available', $this->webAuthnManager->isWebAuthnAvailable());
+		$parameters['throttle_delay'] = $this->throttler->getDelay($this->request->getRemoteAddress());
 
 		// OpenGraph Support: http://ogp.me/
 		Util::addHeader('meta', ['property' => 'og:title', 'content' => Util::sanitizeHTML($this->defaults->getName())]);
@@ -199,71 +209,54 @@
 		Util::addHeader('meta', ['property' => 'og:type', 'content' => 'website']);
 		Util::addHeader('meta', ['property' => 'og:image', 'content' => $this->urlGenerator->getAbsoluteURL($this->urlGenerator->imagePath('core', 'favicon-touch.png'))]);
 
-		$parameters = [
-			'alt_login' => OC_App::getAlternativeLogIns(),
-		];
 		return new TemplateResponse(
 			$this->appName, 'login', $parameters, 'guest'
 		);
 	}
 
 	/**
-	 * Sets the password reset state
-	 *
-	 * @param string $username
-	 */
-	private function setPasswordResetInitialState(?string $username): void {
-		if ($username !== null && $username !== '') {
-			$user = $this->userManager->get($username);
-		} else {
-			$user = null;
-		}
-
-		$passwordLink = $this->config->getSystemValue('lost_password_link', '');
-
-		$this->initialStateService->provideInitialState(
-			'core',
-			'loginResetPasswordLink',
-			$passwordLink
-		);
-
-		$this->initialStateService->provideInitialState(
-			'core',
-			'loginCanResetPassword',
-			$this->canResetPassword($passwordLink, $user)
-		);
-	}
-
-	/**
-	 * @param string|null $passwordLink
-	 * @param IUser|null $user
+	 * Sets the password reset params.
 	 *
 	 * Users may not change their passwords if:
 	 * - The account is disabled
 	 * - The backend doesn't support password resets
 	 * - The password reset function is disabled
 	 *
-	 * @return bool
+	 * @param string $user
+	 * @param array $parameters
+	 * @return array
 	 */
-	private function canResetPassword(?string $passwordLink, ?IUser $user): bool {
-		if ($passwordLink === 'disabled') {
-			return false;
+	private function setPasswordResetParameters(
+		string $user = null, array $parameters): array {
+		if ($user !== null && $user !== '') {
+			$userObj = $this->userManager->get($user);
+		} else {
+			$userObj = null;
 		}
 
-		if (!$passwordLink && $user !== null) {
-			return $user->canChangePassword();
-		}
+		$parameters['resetPasswordLink'] = $this->config
+			->getSystemValue('lost_password_link', '');
 
-		if ($user !== null && $user->isEnabled() === false) {
-			return false;
+		if ($parameters['resetPasswordLink'] === 'disabled') {
+			$parameters['canResetPassword'] = false;
+		} else if (!$parameters['resetPasswordLink'] && $userObj !== null) {
+			$parameters['canResetPassword'] = $userObj->canChangePassword();
+		} else if ($userObj !== null && $userObj->isEnabled() === false) {
+			$parameters['canResetPassword'] = false;
+		} else {
+			$parameters['canResetPassword'] = true;
 		}
 
-		return true;
+		return $parameters;
 	}
 
-	private function generateRedirect(?string $redirectUrl): RedirectResponse {
-		if ($redirectUrl !== null && $this->userSession->isLoggedIn()) {
-			$location = $this->urlGenerator->getAbsoluteURL($redirectUrl);
+	/**
+	 * @param string $redirectUrl
+	 * @return RedirectResponse
+	 */
+	private function generateRedirect($redirectUrl) {
+		if (!is_null($redirectUrl) && $this->userSession->isLoggedIn()) {
+			$location = $this->urlGenerator->getAbsoluteURL(urldecode($redirectUrl));
 			// Deny the redirect if the URL contains a @
 			// This prevents unvalidated redirects like ?redirect_url=:user@domain.com
 			if (strpos($location, '@') === false) {
@@ -282,16 +275,16 @@
 	 * @param string $user
 	 * @param string $password
 	 * @param string $redirect_url
+	 * @param boolean $remember_login
 	 * @param string $timezone
 	 * @param string $timezone_offset
-	 *
 	 * @return RedirectResponse
 	 */
-	public function tryLogin(string $user,
-							 string $password,
-							 string $redirect_url = null,
-							 string $timezone = '',
-							 string $timezone_offset = ''): RedirectResponse {
+	public function tryLogin($user, $password, $redirect_url, $remember_login = true, $timezone = '', $timezone_offset = '') {
+		if(!is_string($user)) {
+			throw new \InvalidArgumentException('Username must be string');
+		}
+
 		// If the user is already logged in and the CSRF check does not pass then
 		// simply redirect the user to the correct page as required. This is the
 		// case when an user has already logged-in, in another tab.
@@ -299,27 +292,96 @@
 			return $this->generateRedirect($redirect_url);
 		}
 
-		$data = new LoginData(
-			$this->request,
-			trim($user),
-			$password,
-			$redirect_url,
-			$timezone,
-			$timezone_offset
-		);
-		$result = $this->loginChain->process($data);
-		if (!$result->isSuccess()) {
-			return $this->createLoginFailedResponse(
-				$data->getUsername(),
-				$user,
-				$redirect_url,
-				$result->getErrorMessage()
-			);
+		if ($this->userManager instanceof PublicEmitter) {
+			$this->userManager->emit('\OC\User', 'preLogin', array($user, $password));
+		}
+
+		$originalUser = $user;
+
+		$userObj = $this->userManager->get($user);
+
+		if ($userObj !== null && $userObj->isEnabled() === false) {
+			$this->logger->warning('Login failed: \''. $user . '\' disabled' .
+				' (Remote IP: \''. $this->request->getRemoteAddress(). '\')',
+				['app' => 'core']);
+			return $this->createLoginFailedResponse($user, $originalUser,
+				$redirect_url, self::LOGIN_MSG_USERDISABLED);
+		}
+
+		// TODO: Add all the insane error handling
+		/* @var $loginResult IUser */
+		$loginResult = $this->userManager->checkPasswordNoLogging($user, $password);
+		if ($loginResult === false) {
+			$users = $this->userManager->getByEmail($user);
+			// we only allow login by email if unique
+			if (count($users) === 1) {
+				$previousUser = $user;
+				$user = $users[0]->getUID();
+				if($user !== $previousUser) {
+					$loginResult = $this->userManager->checkPassword($user, $password);
+				}
 		}
+		}
+
+		if ($loginResult === false) {
+			$this->logger->warning('Login failed: \''. $user .
+				'\' (Remote IP: \''. $this->request->getRemoteAddress(). '\')',
+				['app' => 'core']);
+			return $this->createLoginFailedResponse($user, $originalUser,
+				$redirect_url, self::LOGIN_MSG_INVALIDPASSWORD);
+		}
+
+		// TODO: remove password checks from above and let the user session handle failures
+		// requires https://github.com/owncloud/core/pull/24616
+		$this->userSession->completeLogin($loginResult, ['loginName' => $user, 'password' => $password]);
+
+		$tokenType = IToken::REMEMBER;
+		if ((int)$this->config->getSystemValue('remember_login_cookie_lifetime', 60*60*24*15) === 0) {
+			$remember_login = false;
+			$tokenType = IToken::DO_NOT_REMEMBER;
+		}
+
+		$this->userSession->createSessionToken($this->request, $loginResult->getUID(), $user, $password, $tokenType);
+		$this->userSession->updateTokens($loginResult->getUID(), $password);
+
+		// User has successfully logged in, now remove the password reset link, when it is available
+		$this->config->deleteUserValue($loginResult->getUID(), 'core', 'lostpassword');
+
+		$this->session->set('last-password-confirm', $loginResult->getLastLogin());
 
-		if ($result->getRedirectUrl() !== null) {
-			return new RedirectResponse($result->getRedirectUrl());
+		if ($timezone_offset !== '') {
+			$this->config->setUserValue($loginResult->getUID(), 'core', 'timezone', $timezone);
+			$this->session->set('timezone', $timezone_offset);
 		}
+
+		if ($this->twoFactorManager->isTwoFactorAuthenticated($loginResult)) {
+			$this->twoFactorManager->prepareTwoFactorLogin($loginResult, $remember_login);
+
+			$providers = $this->twoFactorManager->getProviderSet($loginResult)->getPrimaryProviders();
+			if (count($providers) === 1) {
+				// Single provider, hence we can redirect to that provider's challenge page directly
+				/* @var $provider IProvider */
+				$provider = array_pop($providers);
+				$url = 'core.TwoFactorChallenge.showChallenge';
+				$urlParams = [
+					'challengeProviderId' => $provider->getId(),
+				];
+			} else {
+				$url = 'core.TwoFactorChallenge.selectChallenge';
+				$urlParams = [];
+			}
+
+			if (!is_null($redirect_url)) {
+				$urlParams['redirect_url'] = $redirect_url;
+			}
+
+			return new RedirectResponse($this->urlGenerator->linkToRoute($url, $urlParams));
+		}
+
+		if ($remember_login) {
+			$this->userSession->createRememberMeToken($loginResult);
+		}
+
 		return $this->generateRedirect($redirect_url);
 	}
 
@@ -330,15 +392,14 @@
 	 * @param string $originalUser
 	 * @param string $redirect_url
 	 * @param string $loginMessage
-	 *
 	 * @return RedirectResponse
 	 */
 	private function createLoginFailedResponse(
 		$user, $originalUser, $redirect_url, string $loginMessage) {
 		// Read current user and append if possible we need to
 		// return the unmodified user otherwise we will leak the login name
-		$args = $user !== null ? ['user' => $originalUser, 'direct' => 1] : [];
-		if ($redirect_url !== null) {
+		$args = !is_null($user) ? ['user' => $originalUser] : [];
+		if (!is_null($redirect_url)) {
 			$args['redirect_url'] = $redirect_url;
 		}
 		$response = new RedirectResponse(
@@ -356,11 +417,10 @@
 	 * @UseSession
 	 * @BruteForceProtection(action=sudo)
 	 *
-	 * @param string $password
-	 *
-	 * @return DataResponse
 	 * @license GNU AGPL version 3 or any later version
 	 *
+	 * @param string $password
+	 * @return DataResponse
 	 */
 	public function confirmPassword($password) {
 		$loginName = $this->userSession->getLoginName();
